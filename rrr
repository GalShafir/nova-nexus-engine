class MSSQLClient:
    """
    Async client for Microsoft SQL Server, with dynamic connection parameters
    and methods to list databases, tables, columns, and execute arbitrary queries.
    """

    def __init__(
        self,
        host: str,
        port: int,
        user: str,
        password: str,
        database: str = "master"
    ):
        """
        :param host:      SQL Server hostname or IP.
        :param port:      SQL Server port (default: 1433).
        :param user:      Username for authentication.
        :param password:  Password for authentication.
        :param database:  Initial database to connect to (default: 'master').
        """
        self._conn_args = {
            "server": host,
            "port": port,
            "database": database,
            "user": user,
            "password": password
        }
        self._conn: Optional[pytds.Connection] = None

    async def init(self) -> None:
        """
        Initialize the connection to SQL Server.

        This uses pytds.connect() synchronously under the hood,
        offloading to a worker thread so the event loop remains responsive.
        """
        self._conn = await asyncio.to_thread(pytds.connect, **self._conn_args)

    async def close(self) -> None:
        """
        Close the SQL Server connection.

        The synchronous .close() call is wrapped in to_thread() to prevent blocking.
        """
        if self._conn:
            await asyncio.to_thread(self._conn.close)

    async def list_databases(self) -> List[str]:
        """
        Return a list of all user databases on the server,
        excluding system DBs (database_id > 4).
        """
        assert self._conn, "Connection not initialized"

        def _sync_list_dbs():
            cur = self._conn.cursor()
            cur.execute(
                "SELECT name "
                "FROM sys.databases "
                "WHERE database_id > 4;"
            )
            rows = cur.fetchall()
            cur.close()
            return [r[0] for r in rows]

        return await asyncio.to_thread(_sync_list_dbs)

    async def list_tables(self) -> List[str]:
        """
        Return a list of all user tables in the current databaseâ€™s dbo schema
        using INFORMATION_SCHEMA.TABLES.
        """
        assert self._conn, "Connection not initialized"

        def _sync_list_tables():
            cur = self._conn.cursor()
            cur.execute(
                """
                SELECT TABLE_NAME
                  FROM INFORMATION_SCHEMA.TABLES
                 WHERE TABLE_TYPE = 'BASE TABLE'
                   AND TABLE_SCHEMA = 'dbo';
                """
            )
            rows = cur.fetchall()
            cur.close()
            return [r[0] for r in rows]

        return await asyncio.to_thread(_sync_list_tables)

    async def list_keys(self) -> Dict[str, List[str]]:
        """
        Return a mapping of each table to its list of column names
        by querying INFORMATION_SCHEMA.COLUMNS.
        """
        assert self._conn, "Connection not initialized"

        def _sync_list_keys():
            cur = self._conn.cursor()
            cur.execute(
                """
                SELECT TABLE_NAME, COLUMN_NAME
                  FROM INFORMATION_SCHEMA.COLUMNS
                 WHERE TABLE_SCHEMA = 'dbo'
                 ORDER BY TABLE_NAME, ORDINAL_POSITION;
                """
            )
            result: Dict[str, List[str]] = {}
            for table, column in cur.fetchall():
                result.setdefault(table, []).append(column)
            cur.close()
            return result

        return await asyncio.to_thread(_sync_list_keys)

    async def execute_query(self, sql: str) -> List[Dict[str, Any]]:
        """
        Run an arbitrary SQL statement and return rows as list of dicts.
        """
        assert self._conn, "Connection not initialized"

        def _sync_execute():
            cur = self._conn.cursor()
            cur.execute(sql)
            cols = [desc[0] for desc in cur.description]
            rows = cur.fetchall()
            cur.close()
            return [dict(zip(cols, row)) for row in rows]

        return await asyncio.to_thread(_sync_execute)

    async def get_column_values(
        self,
        table: str,
        column: str,
        limit: int
    ) -> List[Any]:
        """
        Return up to `limit` distinct values for `column` in `table`.
        For XML-typed columns (which can't be DISTINCT-ed), falls back
        to a plain TOP query or casts the column to NVARCHAR(MAX).
        """
        assert self._conn, "Connection not initialized"
        def _sync():
            cur = self._conn.cursor()
            # First, try DISTINCT TOP
            distinct_sql = f"SELECT DISTINCT TOP {limit} [{column}] FROM [{table}]"
            try:
                logger.debug("Executing DISTINCT query: %s", distinct_sql)
                cur.execute(distinct_sql)
                rows = cur.fetchall()
                return [row[0] for row in rows]

            except pytds.tds_base.OperationalError as e:
                msg = str(e)
                logger.warning(
                    "DISTINCT failed on %s.%s: %s. Falling back to plain TOP or CAST",
                    table, column, msg
                )
                # Fallback: plain TOP N
                try:
                    plain_sql = f"SELECT TOP {limit} [{column}] FROM [{table}]"
                    logger.debug("Executing fallback SQL: %s", plain_sql)
                    cur.execute(plain_sql)
                    rows = cur.fetchall()
                    return [row[0] for row in rows]
                except pytds.tds_base.OperationalError:
                    # Last resort: cast XML to NVARCHAR(MAX)
                    cast_sql = (
                        f"SELECT TOP {limit} "
                        f"CAST([{column}] AS NVARCHAR(MAX)) "
                        f"FROM [{table}]"
                    )
                    logger.debug("Executing CAST fallback SQL: %s", cast_sql)
                    cur.execute(cast_sql)
                    rows = cur.fetchall()
                    return [row[0] for row in rows]
            finally:
                cur.close()

        # Run the blocking DB work in a thread so the event loop stays responsive
        return await asyncio.to_thread(_sync)

